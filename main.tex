\documentclass[polish, 11pt]{article}

\usepackage[a4paper,
  top=.5cm,
  bottom=2.5cm,
  left=2.5cm,
  right=2.5cm,
  headheight=86pt, % as per the warning by fancyhdr
  includehead,includefoot,
  heightrounded, % to avoid spurious underfull messages
]{geometry}
\usepackage{babel}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{float}
%\usepackage{minted} % na razie zostawiłem ale do pseudokodu minted chyba nie ma wsparcia - jest coś jak algorithm2e ale nie przyglądałem sie bardziej albo po prostu listings
%\usemintedstyle{xcode}
\usepackage{booktabs}
\usepackage{multirow}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\fancyheadoffset[L]{2cm}
\lhead{\includegraphics[height=2cm]{figures/PWRlogo.jpg}\\
    \vspace{3mm}
    Tytuł projektu: Apapp
    \vspace{1mm}
}
\cfoot{Wrocław, 2019}
\rfoot{\thepage}

\begin{document}
{
    \centering
    \Huge{PROJEKTOWANIE SYSTEMÓW INTERNETOWYCH I MOBILNYCH}
\vspace{2cm}

    \huge{WYDZIAŁ ELEKTRONIKI - INFORMATYKA \\ Systemy i Sieci Komputerowe}
\vspace{2cm}

    \LARGE{\textbf{Tytuł projektu: Apapp}}
\vspace{3cm}

    \begin{flushright}
        Zespół projektowy:\\
        Janusz Długosz, 235746\\
        Jakub Dorda, 235013\\
        Marcin Kotas, 235098\\
        Mateusz Polok, 234981
        
    \end{flushright}
}
\newpage
\tableofcontents
\newpage

\section{Cel i zakres projektu}

\section{Technologie informatyczne wykorzystane w projekcie}

\section{Harmonogram prac projektowych – wykres Gantta}

\section{Architektura aplikacji}

\subsection{Android}

Pierwszą warstwą aplikacji mobilnej jest komunikacja sieciowa z REST API. Zapytania sieciowe wykonywane są asynchronicznie z warstwy repozytoriów danych. Repozytoria wykorzystywane są do lokalnego cachowania oraz umożliwiają dostęp do tych samych danych z kilku różnych miejsc kolejnej warstwy abstrakcji. W zależności od potrzeb przy pomocy Dependency Injection repozytorium może być traktowane jako jedno lub wielo-instancyjne. Interfejs publiczny repozytoriów został zbudowany bazując na paradygmacie programowania reaktywnego, implementacja udostępnia obserwowalny, dyskretny potok danych zaimplementowany przy pomocy wzorca projektowego Behaviour Subject (wielu obserwatorów, jeden strumień, dostęp do wartości wyemitowanych w czasie t+1 po subskrypcji obserwatora). Z repozytoriów korzysta bezpośrednio warstwa ViewModelów. ViewModele odpowiadają za definiowanie zachowania widoków aplikacji oraz zapewniają dostęp do danych otrzymywanych z repozytoriów.
ViewModele komunikują się z warstwą widoku (Fragmenty) przy pomocy LiveData będącego częścią biblioteki Android Architecture Components. LiveData jest implementacją wzorca Obserwator z dodatkową świadomością cyklu życia Fragmentu lub innego komponentu widoku do którego przypisany jest obserwator zmiennej LiveData. W uproszczeniu polega to na automatycznej subskrypcji oraz jej usunięciu w zależności czy dany widok aplikacji jest obecnie widoczny dla użytkownika. Umożliwia to dość znaczącą optymalizację, szczególnie w związku z tym, że z niższych warstw nowe wartości otrzymywane są asynchronicznie. Opcjonalną warstwą między ViewModelem a widokiem jest warstwa Data Bindingu, umożliwiająca obsługę modelu danych od razu w kodzie xml. Rozwiązanie to stosowane jest głównie w niezbyt skomplikowanych widokach nie wymagających interaktywności np. listach.     

\section{Opis struktury kodowania aplikacji}

\section{Prezentacja aplikacji}

\section{Analiza SWOT powdrożeniowa}

\end{document}